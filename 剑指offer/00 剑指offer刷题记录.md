## 第一遍不会的题目
### [二维数组中的查找](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&&tqId=11154&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [用两个栈实现队列](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&&tqId=11158&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [旋转数组的最小数字](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [斐波那契数列](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&&tqId=11160&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [跳台阶扩展问题](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&&tqId=11162&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [数值的整数次方](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
两种解法：第一种是快速幂，第二种是普通的连乘。
- 连乘：O(n),O(1)
- 快速幂：O(logn),O(1)
### [反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&&tqId=11168&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&&tqId=11169&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
注意需要额外新建立一个头结点
### [树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solutions/144306/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/)
树的题目一般都用递归
### [顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
挺好的，考验细节，代码能力
### [二叉搜索树的后序遍历序列](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [二叉树中和为某一值的路径(二)](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&&tqId=11178&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [二叉搜索树与双向链表](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&&tqId=11180&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
利用到了堆排序
### [连续子数组的最大和](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&&tqId=11183&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [整数中1出现的次数](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [把数组排成最小的数](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&&tqId=11185&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [丑数](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [二叉树的深度](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&&tqId=11191&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [判断是不是平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&&tqId=11192&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [和为S的连续正数序列](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&&tqId=11194&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [和为S的两个数字](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&&tqId=11195&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [扑克牌顺子](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&&tqId=11198&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [孩子们的游戏](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [求1+2+3+...+n](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&&tqId=11200&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [不用加减乘除做加法](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&&tqId=11201&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [正则表达式匹配](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [No53、表示数值的字符串](https://interviewguide.cn/notes/03-hunting_job/03-algorithm/02-sword-offer/53-%E5%89%91%E6%8C%87offer.html)
### [字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&&tqId=11207&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [No62、二叉搜索树的第K个节点](https://interviewguide.cn/notes/03-hunting_job/03-algorithm/02-sword-offer/62-%E5%89%91%E6%8C%87offer.html)
给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4.
来一个遍历将节点和对应的值保存在一个字典里面，然后对字典进行排序，返回第k小的节点即可
### [序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&&tqId=11214&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [数据流中的中位数](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&&tqId=11216&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [矩阵中的路径](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&&tqId=11218&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [机器人的运动范围](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&&tqId=11219&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### [剪绳子_牛客题霸_牛客网](https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 第二遍
1. [旋转数组的最小数字](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
2. [二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
数字1与二进制数每一位相&，结果为0，则二进制数对应的这一位数字为0，否则为1.因此只要用1与二进制每一位相与，就可以得到二进制中哪一位为1了。遍历二进制中每一位，可以用1配合左移运算符。
3. [数值的整数次方](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
注意快速幂的写法
4. [树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solutions/144306/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/)
5. [顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
6. [二叉搜索树的后序遍历序](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
每一次递归内部可以分为两步，第一步想好本次递归结束条件有哪些，第二步想好再次调用递归函数如何写。
7. [二叉树中和为某一值的路径(二)](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
其实就是中序遍历，遍历期间加上一些代码来解决问题。
8. [复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&&tqId=11178&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
两种解法，一种空间复杂度为O(n),一种为O(1)
9. [字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&&tqId=11180&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
依旧不会写
10. [最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
思想其实很简单，主要是heapq模块的应用
11. [连续子数组的最大和_牛客题霸](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&&tqId=11183&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
好题，动态规划的思想值的好好研究
12. [整数中1出现的次数](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
找规律
13. [把数组排成最小的数(nowcoder.com)](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&&tqId=11185&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
排序就完事了
14. [丑数](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
很棒，又是小顶堆
15. [两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
挺简单的，没那么难
16. [判断是不是平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&&tqId=11192&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
还需再做一遍，思路不够清晰
17. [和为S的两个数字](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&&tqId=11195&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
挺好的，有思路也要能写出来
18. [孩子们的游戏(圆圈中最后剩下的数)](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
找规律加递归
19. [求1+2+3+...+n](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&&tqId=11200&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
位运算符 &、|、^、<<、>>、~
逻辑运算符 and or not
递归+逻辑与的短路特性
20. [不用加减乘除做加法](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&&tqId=11201&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
知识点：两数异或可以提供两数相加后的非进位信息，两数相与可以提供相加后的进位信息。
21. [正则表达式匹配](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
还是不会，没有思路
22. [序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&&tqId=11214&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
有点难，没思路
23. [剪绳子(nowcoder.com)](https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
24. [矩阵中的路径](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&&tqId=11218&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
25. [机器人的运动范围](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&&tqId=11219&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
## 第三遍
1、 [旋转数组的最小数字](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
法1：遍历整个数组，可以找到整个数组中的最小值。
法2：对于有顺序的数组可以采取二分法，题目中旋转数组肯能是两个旋转数组的组合，也可用二分法。注意当m和j索引的值相同时，最小值可能在i~m或者m~j中，不能断定在哪个序列中，因此缩小搜索范围，让j=j-1.
```python
class Solution:
    def minNumberInRotateArray(self , nums: List[int]) -> int:
        # write code here
        i = 0
        j = len(nums)-1
        while i < j:
            m = (i+j) // 2
            if nums[m] > nums[j]:i=m+1
            elif nums[m] < nums[j]:j=m
            else: j-= 1
        return nums[i]
```

1. [二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
数值在计算机中的表示，原码反码和补码：[负数求补码_负数的补码-CSDN博客](https://blog.csdn.net/love_gzd/article/details/85085084)
数字1与二进制数每一位相&，结果为0，则二进制数对应的这一位数字为0，否则为1.因此只要用1与二进制每一位相与，就可以得到二进制中哪一位为1了。遍历二进制中每一位，可以用1配合左移运算符。
```python
class Solution:
    def NumberOf1(self , n: int) -> int:
        # write code here
        res = 0
        # 遍历32位
        for i in range(32):
            # 按位比较
            if (n & (1 << i)) != 0:
                res += 1
        return res
```
3. [数值的整数次方](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
注意快速幂的写法
快速幂复杂度为$log_2n$,而直接连乘时间复杂度为n。
```python
class Solution:
    def Power(self , base: float, exponent: int) -> float:
        # write code here
        def cal(base, exponent):
            res = base
            flag = exponent
            while flag != 1:
                res *= res
                flag = flag>>1
            if exponent == 1:
                return res
            elif exponent % 2 != 0:
                return res*base
            else:
                return res
        
        if exponent == 0:
            return 1
        elif exponent > 0:
            return cal(base, exponent)
        else:
            res = cal(base, abs(exponent))
            return 1/res
```
4. [树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solutions/144306/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/)
注意题目，这里是判断树B是否是树A某个子树的子结构（一部分），并不一定要与A的某个子树完全一致。
```python
class Solution:
    def is_sub(self, A, B):
        # 判断B是否是A的子树或子树的一部分
        def recur(A, B):
            # A，B根节点相同时，判断B是否是A的一部分，或者等于A
            if not B: return True
            if not A or A.val != B.val: return False
            return recur(A.left, B.left) and recur(A.right, B.right)
        
        return bool(A and B) and (recur(A, B) or self.is_sub(A.left, B) or self.is_sub(A.right, B))
```
1. [顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
设置好对应的边界，用循环遍历，根据边界是否重合或者越界来决定如何遍历矩阵。
```python
# -*- coding:utf-8 -*-
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        # write code here
        res = list()
        n = len(matrix)  # 行数
        if n == 0: return res
        # 设置边界
        left = 0
        right = len(matrix[0]) - 1
        up = 0
        down = n - 1
        # 循环终止条件，直到边界重合
        while left <= right and up <= down:
            # 遍历第up行
            for i in range(left, right+1):
                res.append(matrix[up][i])
            # 上边界向下
            up += 1
            if up > down:
                break

            # 遍历第right列
            for i in range(up, down+1):
                res.append(matrix[i][right])
            # 右边界向左
            right -= 1
            if left > right:
                break

            # 遍历第down行
            for i in range(right, left-1, -1):
                res.append(matrix[down][i])
            # 下边界向上
            down -= 1
            if up > down:
                break
            
            # 遍历第left列
            for i in range(down, up-1, -1):
                res.append(matrix[i][left])
            # 左边界向右
            left += 1
            if left > right:
                break
        return res
```
1. [二叉搜索树的后序遍历序](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
每一次递归内部可以分为两步，第一步想好本次递归结束条件有哪些，第二步想好再次调用递归函数如何写。
感觉对边界条件判断不够清晰！！！
```python
    def get_index(self, seq, root):
        for i in range(len(seq)):
            if seq[i] > root:
                return i 
        # 如果都小于root，说明都是左子树
        return -1     
            
    def VerifySquenceOfBST(self, seq):
        # 判断一个序列seq是否是二叉搜索树的后序遍历
        # 二叉搜索树左子节点<根节点<右子节点
        if len(seq) == 0: return False

        def sub(seq):
            if len(seq) <= 1: return True

            # 获取当前序列的左右子树序列                      
            root = seq[-1]
            index = self.get_index(seq, root)
            left = seq[:index]
            right = seq[index:-1]

            # 判断左子树序列值是否都小于root值，右子树序列值是否都大于root值
            for i in range(len(left)):
                if left[i] > root:
                    return False
            for i in range(len(right)):
                if right[i] < root:
                    return False
                
            # 递归调用判断每个子序列是否满足二叉搜索树
            return sub(left) and sub(right)
        
        return sub(seq)
```
7. [二叉树中和为某一值的路径(二)](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
```python
class Solution:
    def FindPath(self , root: TreeNode, target: int):
        # write code here
        ret, path = [], []
        def dfs(root, target):
            if not root: return
            # 路径更新
            path.append(root.val)
            target -= root.val
            # 如果递归当前节点为叶子结点且该路径的值达到了expectNumber，则更新ret
            if not root.left and not root.right and target == 0:
                ret.append(path[:])
            # 左右子树递归
            dfs(root.left, target)
            dfs(root.right, target)
            path.pop()  # path中的最后一个节点删除
        dfs(root, target)
        return ret
```
8. [复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&&tqId=11178&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```python
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        # write code here
        # 遍历链表，将next分支连起来
        if not pHead: return None
        root_cp = RandomListNode(pHead.label)
        cur_cp = root_cp
        cur = pHead
        # 储存random对应的节点
        random_list = []
        while cur:
            if cur.next:
                cur_cp.next = RandomListNode(cur.next.label)
            else:
                cur_cp.next = None
            if cur.random:
                random_list.append(RandomListNode(cur.random.label))
            else:
                random_list.append(None)

            cur = cur.next
            cur_cp = cur_cp.next
        
        # 将random节点连接
        cur = root_cp
        i = 0
        while cur:
            cur.random = random_list[i]
            i += 1
            cur = cur.next
        return root_cp
```

8. [字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&&tqId=11180&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

算法复杂度(n!)，字符串过长时，程序运行时间会很长

```python
class Solution:
    def Permutation(self , str: str):
        # write code here
        n = len(str)
        if n<=1:
            return str
        lst = []
        for i in range(n):
            s1 = str[i]
            for s2 in self.Permutation(str[:i]+str[i+1:]):
                new_str = s1 + s2
                if new_str not in lst:
                    lst.append(new_str)
        lst=sorted(lst)

        return lst
    
if __name__ == "__main__":
    s = Solution()
    res = s.Permutation("qwert")
    print(res,len(res))
```



8. [最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
     法1：思想其实很简单，主要是heapq模块的应用;

     法2：每次从列表中抽取一个最小的数即可，然后将该最小的数从列表中排除，继续抽取最小的数，直到达到k个

```python
class Solution:
    def GetLeastNumbers_Solution(self , input: List[int], k: int):
        # write code here
        
        res = []
        while len(res) < k:
            # 排除那个最小元素后的列表
            min_num = min(input)
            for i in range(len(input)):
                if input[i] == min_num:
                    break
            if i == len(input)-1:
                input = input[:i]
            else:
                input = input[:i]+input[i+1:]
            res.append(min_num)
        return res
```

8. [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/submissions/504734011/)
      好题，动态规划的思想值的好好研究

```python
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        if n<= 1: return nums[0]
        # dp数组，储存长度从0到len(num_list)的数组的从未知位置到数组长度的子数组的最大值
        dp = [nums[0]]  
        res = nums[0]  # 记录整个数组的所有连续子数组和的最大值
        for i in range(1, n):
            if nums[i] + dp[i-1] > nums[i]:
                dp.append(nums[i] + dp[i-1])
            else:
                dp.append(nums[i])
            if dp[i] > res:
                res = dp[i]
        return res 
```

8. [整数中1出现的次数](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

   找好规律有思路再写

9. [把数组排成最小的数(nowcoder.com)](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&&tqId=11185&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```python
class Solution:
    def PrintMinNumber(self , numbers) -> str:
        # write code here
        if not numbers:
            return ""
        nums = list(map(str, numbers))

        # 冒泡排序
        for i in range(len(nums) -1):
            for j in range(len(nums) - i -1):
                s1 = nums[j] + nums[j+1]
                s2 = nums[j+1] + nums[j]
                if s1 > s2:
                    temp = nums[j]
                    nums[j] = nums[j+1]
                    nums[j+1] = temp
        return "".join(nums)   
```

8. [丑数](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

     注意每次对比的丑数大小

     ```python
     class Solution:
         def GetUglyNumber_Solution(self , index: int):
             # write code here
             # 丑数的2,3,5倍都是丑数
             if index == 0: return 0
             res = [1]
             i2 = 0; i3 = 0; i5 = 0
             while len(res) < index:
                 res.append(min(res[i2]*2, res[i3]*3, res[i5]*5))
                 if res[-1] == res[i2]*2: i2 += 1
                 if res[-1] == res[i3]*3: i3 += 1
                 if res[-1] == res[i5]*5: i5 += 1                        
             return res[-1]
     ```

9. [两个链表的第一个公共结点](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

      ```python
      class Solution:
          def FindFirstCommonNode(self , pHead1 , pHead2 ):
              # write code here
              # 储存某一个链表的遍历顺序,遍历第二个链表时，判断是否有重复值
              save = []
              # 将pHead1的每个节点存下来
              cur = pHead1
              while cur:
                  save.append(cur)
                  cur = cur.next
              # 遍历第二个链表，与save中元素对比，看看是否有重复的
              cur = pHead2
              while cur:
                  if cur in save:
                      return cur
                  else:
                      cur = cur.next
              return None
      ```

10. [判断是不是平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&&tqId=11192&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```python
class Solution:
    def get_hight(self, root):
        # 广度优先遍历获取树的高度
        quene = [root]
        hight = 0
        while quene:
            n = len(quene)
            for _ in range(n):
                cur = quene.pop(0)
                if cur.left: quene.append(cur.left)
                if cur.right: quene.append(cur.right)
            hight += 1
        return hight

    def IsBalanced_Solution(self , pRoot: TreeNode) -> bool:
        # write code here
        if not pRoot: return True

        left_hight = self.get_hight(pRoot.left) if pRoot.left else 0
        right_hight = self.get_hight(pRoot.right) if pRoot.right else 0

        diff = abs(left_hight - right_hight)
        if diff > 1:
            return False
        else:
            return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
```

8. [和为S的两个数字](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&&tqId=11195&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```python 
class Solution:
    def FindNumbersWithSum(self , array: List[int], sum: int) -> List[int]:
        # write code here
        # 运行超时 时间复杂度为O(n**2)
        n = len(array)
        if n==0: return []
        res = []
        for i in range(n-1):
            if i > (sum // 2 + 1):
                break
            for j in range(i+1, n):
                if array[i] + array[j] == sum:
                    res.extend([array[i], array[j]])
                    return res
        return []
    # ------------------------------------------------------------------------------------------------------
    class Solution:
    def FindNumbersWithSum(self , array: List[int], sum: int) -> List[int]:
        # 根据数组有序性，利用双指针解决问题，时间复杂度为O(n)
        n = len(array)
        if n == 0: return []

        left = 0
        right = n-1
        while left < right:
            if array[left] + array[right] < sum:
                left += 1
            elif array[left] + array[right] > sum:
                right -= 1
            else:
                return [array[left], array[right]]
        return []
```

8. [孩子们的游戏(圆圈中最后剩下的数)](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

认真读题，在纸上进行模拟，寻找解题方案。

```python
class Solution:
    def LastRemaining_Solution(self , n: int, m: int) -> int:
        # write code here
        if n == 1: return n-1

        members = list(range(n))
        cur = 0
        while len(members) > 1:
            cur = (cur+(m-1)) % len(members)
            members.pop(cur)
            cur = cur % len(members)
        return members[-1]
```

8. [求1+2+3+...+n](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&&tqId=11200&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
                  位运算符 &、|、^、<<、>>、~
                  逻辑运算符 and or not
                  递归+逻辑与的短路特性

```python
# 递归，但是用到了if
class Solution:
    def __init__(self):
        self.sum = 0

    def Sum_Solution(self, n):
        # write code here
        if n == 0: return 
        self.sum += n
        n -= 1
        self.Sum_Solution(n)
        return self.sum
# 不用if，for，while，乘除等
# 与运算的短路递归，不用if，我们需要知道什么时候终止递归，与运算可以进行短路（第一个条件不满足就不会执行第二个语句）
class Solution:
    def __init__(self):
        self.sum = 0

    def Sum_Solution(self, n):
        # write code here
        n > 1 and self.Sum_Solution(n-1)
        self.sum += n
        return self.sum
```

8. [不用加减乘除做加法](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&&tqId=11201&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
       知识点：两数异或可以提供两数相加后的非进位信息，两数相与可以提供相加后的进位信息。这题有问题，说不能用加减法可是题解中还是用了，而且下面的题解如果输入为-1,0时会出错。

```python
class Solution:
    def Add(self , num1: int, num2: int) -> int:
        # write code here
        # 两数相与得到两数相加时对应每一位的进位情况，两数相异或得到每一位的实际值
        # 将进位左移1位，再次与上次异或结果进行相与和异或，直到进位为0，返回异或结果即可
        while num2:
            a = (num2 & num1) << 1  # 进位
            b = num2 ^ num1  # 非进位
            b = b & 0xFFFFFFFF
            num2 = a
            num1 = b
        return num1 if num1>>31==0 else num1 - 4294967296
```

8. [正则表达式匹配](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

题目描述：请实现一个函数用来匹配包括`.`和`*`的正则表达式。模式中的字符'.'表示任意一个字符，而`*`表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和`ab*ac*a`匹配，但是与"aa.a"和"ab*a"均不匹配。

```python
"aaa", "a*a", "ab*ac*a"  # True
```

```python
def is_match(s, p):
    if not p:
        return not s
    # 判断第一个字符是否匹配
    first_match = bool(s) and p[0] in {s[0], '.'}
    if len(p) >= 2 and p[1] == '*':
        # is_match(s, p[2:])相当于模版中当前*前面字符出现了0次
        # first_match and is_match(s[1:], p)则是出现了1次或者多次
        return is_match(s, p[2:]) or (first_match and is_match(s[1:], p))
    else:
        return first_match and is_match(s[1:], p[1:])

# 测试
print(is_match("aaa", "a*a"))   # True
print(is_match("abaca", "ab*a"))   # False
```

8. [序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&&tqId=11214&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

值的好好研究

```python
import sys
#设置递归深度
sys.setrecursionlimit(100000) 
class Solution:
    def __init__(self):
        self.index = 0 
        self.s = ""

    #处理序列化（递归）
    def SerializeFunction(self, root):
        #空节点
        if not root:
            self.s += '#'
            return
        #根节点
        self.s += (str)(root.val) + '!'
        #左子树
        self.SerializeFunction(root.left) 
        #右子树
        self.SerializeFunction(root.right) 
    
    def Serialize(self, root): 
        if not root:
            return '#'
        self.s = ""
        self.SerializeFunction(root)
        return self.s
    
    #处理反序列化的功能函数（递归）
    def DeserializeFunction(self, s: str):
        # 到达叶节点时，构建完毕，返回继续构建父节点
        #空节点
        if self.index >= len(s) or s[self.index] == "#": 
            self.index += 1
            return None
        # 数字转换
        val = 0
        #遇到分隔符或者结尾
        while s[self.index] != '!' and self.index != len(s):
            val = val * 10 + (int)(s[self.index])
            self.index += 1
        root = TreeNode(val)
        #序列到底了，构建完成
        if self.index == len(s): 
            return root
        else:
            self.index += 1
        #反序列化与序列化一致，都是前序
        root.left = self.DeserializeFunction(s)  
        root.right = self.DeserializeFunction(s)
        return root

    def Deserialize(self, s):
        if s == "#":
            return None
        return self.DeserializeFunction(s)
```



8. [剪绳子(nowcoder.com)](https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

这种没有一下看出思路的题目，可以尝试模拟找规律，从n=1~n=xxx，多模拟几个找找规律

```python
class Solution:
    def cutRope(self , n: int) -> int:
        # write code here
        if n <= 4: return n
        # 将n分成由3组成的段，如果分不成则尝试2
        num_3 = n // 3
        if n % 3 == 0: return 3**num_3
        # 如果余数为2
        if n % 3 == 2: return 3**num_3*2
        # 如果余数为1，则减少3的那一段，结合1，分成2段2*2
        if n % 3 == 1: return 3**(num_3-1)*2*2
```

8. 矩形中的路径

**题目描述：**请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。*路径可以从矩阵中的任意一个格子开始*，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

**示例：**"ABCESFCSADEE",3,4,"ABCCED"：true             "ABCESFCSADEE",3,4,"ABCB"： false

```python
def exist(board, word):
    if not board: return False

    rows = len(board)
    cols = len(board[0])
    # 构建一个矩阵，标志board中元素访问状态
    visited = [[False for _ in range(cols)] for _ in range(rows)]

    def dfs(i, j, index):
        # 深度优先遍历
        if index == len(word):  # index表示当前正在匹配的word中字符的索引
            return True
        if i < 0 or i >= rows or j < 0 or j >= cols or visited[i][j] or board[i][j] != word[index]:
            return False

        visited[i][j] = True  # 说明当前字符是匹配到了

        # 递归判断上下左右字符与word中下一个字符是否匹配
        if dfs(i+1, j, index+1) or dfs(i-1, j, index+1) or dfs(i, j+1, index+1) or dfs(i, j-1, index+1):
            return True

        # 如果都行不通，将当前board中的字符设置为未访问过，以方便其他路径进行访问
        visited[i][j] = False

        return False

    for i in range(rows):
        for j in range(cols):
            if dfs(i, j, 0):
                return True
    return False


if __name__ == "__main__":
    # 示例用法
    board = [
    ['a','b','c','e'],
    ['s','f','c','s'],
    ['a','d','e','e']
    ]
    word1 = "bcced"
    word2 = "abcb"
    print(exist(board, word1))  # 输出 True
    print(exist(board, word2))  # 输出 False
```

8. [机器人的运动范围](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&&tqId=11219&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

递归与回溯，和矩形中的路径相似的题目。多练几遍吧

```python
"""
定义一个函数 get_digit_sum 来计算一个数字的数位之和。
定义一个函数 movingCountDFS 来进行深度优先搜索，从起始位置 (0, 0) 开始，搜索所有符合条件的格子。
在搜索过程中，判断当前位置是否越界、是否已经访问过、以及数位之和是否符合条件。
如果当前位置符合条件，将其标记为已访问，并继续向四个方向进行深度优先搜索。
最终返回所有符合条件的格子数目。
"""

def movingCount(rows, cols, threshold):
    def get_digit_sum(num):
        sum = 0
        while num > 0:
            sum += num % 10
            num //= 10
        return sum
    
    def movingCountDFS(i, j):
        if i < 0 or i >= rows or j < 0 or j >= cols or visited[i][j] or get_digit_sum(i) + get_digit_sum(j) > threshold:
            return 0

        visited[i][j] = True
        count = 1
        count += movingCountDFS(i+1, j)
        count += movingCountDFS(i-1, j)
        count += movingCountDFS(i, j+1)
        count += movingCountDFS(i, j-1)  
        return count

    visited = [[False for _ in range(cols)] for _ in range(rows)]
    return movingCountDFS(0, 0)


# 示例用法
rows = 3
cols = 3
threshold = 2
print(movingCount(rows, cols, threshold))  # 输出 6
```



## 第四遍
1. [二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
2. [树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solutions/144306/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/)
3. [顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
4. [二叉搜索树的后序遍历序](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
5. [二叉树中和为某一值的路径(二)](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
6. [字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&&tqId=11180&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
7. [整数中1出现的次数](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
8. [把数组排成最小的数(nowcoder.com)](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&&tqId=11185&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
9. [丑数](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
10. [求1+2+3+...+n（写出所有解题方法）](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&&tqId=11200&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
11. [正则表达式匹配](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
12. [序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&&tqId=11214&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
13. 矩形中的路径
14. [机器人的运动范围](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&&tqId=11219&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
